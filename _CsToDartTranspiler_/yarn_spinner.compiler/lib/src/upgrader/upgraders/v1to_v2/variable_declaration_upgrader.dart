import 'package:yarn_spinner.compiler.framework/src/upgrader/i_language_upgrader.dart';
import 'package:yarn_spinner.compiler.framework/src/upgrader/language_upgrader.dart';
import 'package:yarn_spinner.compiler.framework/src/upgrader/upgraders/v1to_v2/type_binding.dart';
import 'package:yarn_spinner.compiler.framework/src/upgrader/upgraders/v1to_v2/yarn_spinner_v1_lexer.dart';
import 'package:yarn_spinner.compiler.framework/src/upgrader/upgraders/v1to_v2/yarn_spinner_v1_parser.dart';
import 'package:yarn_spinner.compiler.framework/src/upgrader/upgraders/v1to_v2/yarn_spinner_v1_parser_base_visitor.dart';
import 'package:yarn_spinner.framework/yarn_spinner.framework.dart';
class VariableDeclarationUpgrader implements ILanguageUpgrader {


  @override
  UpgradeResult upgrade(UpgradeJob upgradeJob) {
    var potentialTypeBindings = OrderedSet<TypeBinding>();
    var allSeenVariables = OrderedSet<String>();

    for (var file in upgradeJob.files) {
      ICharStream input = CharStreams.fromstring(file.source);
      YarnSpinnerV1Lexer lexer = YarnSpinnerV1Lexer(input);
      CommonTokenStream tokens = CommonTokenStream(lexer);
      YarnSpinnerV1Parser parser = YarnSpinnerV1Parser(tokens);

      DialogueContext tree = parser.dialogue();

      var declarationVisitor = _VariableTypeBindingVisitor(potentialTypeBindings, allSeenVariables);
      declarationVisitor.visit(tree);
    }

    // We now have information on which variables exist, and
    // potentially what type they are. We can now do a pass,
    // rewriting certain expressions.
    var outputFiles = List<OutputFile>();
    for (var file in upgradeJob.files) {
      ICharStream input = CharStreams.fromstring(file.source);
      YarnSpinnerV1Lexer lexer = YarnSpinnerV1Lexer(input);
      CommonTokenStream tokens = CommonTokenStream(lexer);
      YarnSpinnerV1Parser parser = YarnSpinnerV1Parser(tokens);

      DialogueContext tree = parser.dialogue();

      var replacements = List<TextReplacement>();

      var declarationVisitorWithReplacements = _VariableTypeBindingVisitor(potentialTypeBindings, allSeenVariables, replacements);
      declarationVisitorWithReplacements.visit(tree);

      outputFiles.add(OutputFile(file.fileName, replacements, file.source));
    }

    List<TypeBinding> unifiedVariableBindings = TypeBinding.unifyBindings(potentialTypeBindings);

    // We finally have our bindings. Generate declarations for them.
    var allBindings = unifiedVariableBindings.toDictionary((b) => b.VariableName, (b) => b.Type);

    if (allSeenVariables.count() > 0) {
      // If we're here, we've got variables, and we need to
      // generate declarations for them. We'll do this by
      // generating a node in a new file that contains them.
      var declarationsNodeStringBuilder = StringBuilder();

      // declarationsNodeStringBuilder.AppendLine
      var preambleLines = ["title: _AutoGeneratedVariableDeclarations", "tags: generated ys-upgrade-v1-to-v2", "---", "// NOTE: These variable declarations were automatically generated as part", "// of the upgrade process. Please check these before using them in your", "// game."];

      for (var line in preambleLines) {
        declarationsNodeStringBuilder.appendLine(line);
      }

      declarationsNodeStringBuilder.appendLine();

      // Create a dictionary that maps a type to a string that
      // will be used in declarations. This string contains the
      // name of the type as defined in Yarn, as well as a
      // default value.
      var typesToStrings = {BuiltinTypes.bool: "false as bool", BuiltinTypes.number: "0 as number", BuiltinTypes.String: """"" as string"};

      for (var variableName in allSeenVariables) {
        IType type;

        if (allBindings.containsKey(variableName)) {
          type = allBindings[variableName];
        }
        else {
          type = BuiltinTypes.IType;
        }

        var typeIsDefined = type != BuiltinTypes.IType;

        declarationsNodeStringBuilder.append("<<declare ");
        declarationsNodeStringBuilder.append(variableName);
        declarationsNodeStringBuilder.append(" = ");

        if (typeIsDefined) {
          declarationsNodeStringBuilder.append(typesToStrings[type]);
        }
        else {
          declarationsNodeStringBuilder.append("undefined");
        }

        declarationsNodeStringBuilder.append(">>");
        declarationsNodeStringBuilder.appendLine();
      }

      declarationsNodeStringBuilder.appendLine("===");

      var outputDirectory = System.IO.Path.getDirectoryName(upgradeJob.files.first().FileName);
      var outputFileName = System.IO.Path.combine(outputDirectory, "Program.yarnproject");

      var declarationsOutputFile = OutputFile(outputFileName, declarationsNodeStringBuilder.toString());

      outputFiles.add(declarationsOutputFile);
    }


    var result = UpgradeResult;
    result.files = outputFiles;
    return result;
  }

}
class _VariableTypeBindingVisitor extends YarnSpinnerV1ParserBaseVisitor<IType> {
  OrderedSet<TypeBinding> _potentialTypeBindings;

  OrderedSet<String> _allSeenVariables;

  ICollection<TextReplacement> _replacements;

  _VariableTypeBindingVisitor(OrderedSet<TypeBinding> potentialTypeBindings, OrderedSet<String> allSeenVariables, [ICollection<TextReplacement> replacements = null]) {
    _potentialTypeBindings = potentialTypeBindings;
    _allSeenVariables = allSeenVariables;
    _replacements = replacements;
  }

  // This class generates replacements if a Replacements collection was provided.
  bool get generateReplacements => _replacements != null;

  IType get defaultResult => BuiltinTypes.IType;

  IType visitValueString(ValueStringContext context) {
    return BuiltinTypes.String;
  }

  IType visitValueTrue(ValueTrueContext context) {
    return BuiltinTypes.bool;
  }

  IType visitValueFalse(ValueFalseContext context) {
    return BuiltinTypes.bool;
  }

  IType visitValueNumber(ValueNumberContext context) {
    return BuiltinTypes.number;
  }

  IType visitValueVar(ValueVarContext context) {
    return visitVariable(context.variable());
  }

  IType visitVariable(VariableContext context) {
    // The type of the value depends on the declared type of the
    // variable.

    // Note that we've seen a variable by this name, in case we
    // don't see it again and we never decide on a type for it
    var name = context.vAR_ID().getText();
    _allSeenVariables.add(name);

    // Search our list of variable type bindings. If we have
    // precisely one binding at the moment for the variable, we
    // assume that we know its type, and return that value.
    // Otherwise, we return 'undefined' for this value (either
    // because we have no binding for this variable, or because
    // we have more than one.)
    var bindings = _potentialTypeBindings.where((b) => b.VariableName == name);

    return bindings.count() != 1 ? BuiltinTypes.IType : bindings.first().Type;
  }

  IType visitValueNull(ValueNullContext context) {
    // Null is not a permitted type in Yarn Spinner, so we have
    // to return undefined here
    return BuiltinTypes.IType;
  }

  IType visitValueFunc(ValueFuncContext context) {
    // In Yarn Spinner 1, we don't know the return type OR the
    // parameter types of functions. This means that we can't
    // use return type information, and we'll always return
    // Undefined. We will, however, make sure we visit all
    // parameters, since it contain expressions that result in
    // a variable being bound to a type.

    // Check each parameter of the function
    var suppliedParameters = context.function().expression();

    for (int i = 0; i < suppliedParameters.length; i++) {
      var suppliedParameter = suppliedParameters[i];

      visit(suppliedParameter);
    }

    return BuiltinTypes.IType;
  }

  IType visitExpValue(ExpValueContext context) {
    // Value expressions have the type of their inner value
    return Visit(context.value());
  }

  IType visitExpParens(ExpParensContext context) {
    // Parens expressions have the type of their inner expression
    return Visit(context.expression());
  }

  IType visitExpAndOrXor(ExpAndOrXorContext context) {
    return _checkOperation(context, context.expression(), context.op.Text, BuiltinTypes.bool);
  }

  IType _checkOperation(ParserRuleContext context, List<ParserRuleContext> terms, String operationType, List<IType> permittedTypes) {

    var types = List<IType>();

    // Get all defined types from our terms
    var termsToTypes = terms.toDictionary((t) => t, (t) => visit(t));

    var termTypes = termsToTypes.Values;

    // If any of our terms are undefined, and they are NOT
    // variables (which is ok, because they might be defined
    // later!), then this expression is itself undefined.
    var nonVariableTerms = terms.OfType<YarnSpinnerV1Parser.ExpressionContext>().where((c) => c.GetChild<YarnSpinnerV1Parser.ValueVarContext>(0) == null);

    for (var term in nonVariableTerms) {
      if (termsToTypes[term] == BuiltinTypes.IType) {
        return BuiltinTypes.IType;
      }

    }

    // For any terms that are variables, check to see if we
    // have any knowledge of what types they are.

    // Start by getting all variable terms - that is, entries
    // in term that contain a ValueVarContext (which will
    // itself have a VariableContext in it); with these, take
    // their names
    var variableNames = terms.OfType<YarnSpinnerV1Parser.ExpressionContext>().select((c) => c.GetChild<YarnSpinnerV1Parser.ValueVarContext>(0)).where((c) => c != null).select((v) => v.variable().vAR_ID().getText()).distinct();

    // Next, get the potential types of these variables where
    // we know anything about their type
    var variableTypes = _potentialTypeBindings.where((b) => variableNames.contains(b.VariableName)).select((b) => b.Type).distinct();

    // The collection of types participating in this expression
    // is equal to the collection of the constant values and
    // sub-expressions of the terms present, as well as the
    // types of the variables present that we know about. This
    // will ideally be exactly one.
    var potentialExpressionTypes = termTypes.concat(variableTypes).where((t) => t != BuiltinTypes.IType).distinct();

    // If we have precisely one type of this expression, then
    // we can conclude that any variables participating in that
    // expression should be bound to that type.
    if (potentialExpressionTypes.count() == 1) {
      IType type = potentialExpressionTypes.first();

      if (permittedTypes.contains(type) == false) {
        // We resolved to a specific type, but this
        // operation doesn't permit that type. This
        // expression is therefore invalid, and therefore
        // its type is undefined.
        return BuiltinTypes.IType;
      }


      // Create a type binding for each variable to this
      // type.
      for (var variableName in variableNames) {
        var typeBinding0 = TypeBinding;
        typeBinding0.type = type;
        typeBinding0.variableName = variableName;
        _potentialTypeBindings.add(typeBinding0);
      }

      return type;
    }
    else {
      // TODO: consider handling the situation where we have
      // multiple types participating in this expression, or
      // have no information on what the type could be.
      //
      // For example, an expression like 1 + "1" in Yarn
      // Spinner 1 was handled by converting the non-string
      // operand to a string.
      //
      // For the moment, return Undefined.
      return BuiltinTypes.IType;
    }
  }

  IType visitIf_clause(If_clauseContext context) {
    ExpressionContext expressionContext = context.expression();
    _checkAndRewriteIfClause(context, expressionContext);

    return BuiltinTypes.bool;
  }

  IType visitElse_if_clause(Else_if_clauseContext context) {
    ExpressionContext expressionContext = context.expression();
    _checkAndRewriteIfClause(context, expressionContext);

    return BuiltinTypes.bool;
  }

  void _checkAndRewriteIfClause(ParserRuleContext context, ExpressionContext expressionContext) {
    // Evaluate the if statement's expression. In YS2, if
    // statement expressions are required to be bool, but in
    // YS1, they can be any type. In this upgrader, we 'permit'
    // the type to also be int, and if it is, we'll later
    // rewrite the expression to be of the type "EXP != 0" by
    // running it through the checker with 'upgrades' enabled
    var expressions = [expressionContext];

    var type = _checkOperation(context, expressions, "if statement", BuiltinTypes.bool, BuiltinTypes.number);

    if (generateReplacements && type == BuiltinTypes.number) {

      // This if statement resolved to a number expression,
      // and we want to generate replacements. We'll generate
      // a replacement that converts it to a bool.

      // A 'simple expression' is on where the expression is
      // just a value, eg <<if $x>>. A complex expression is
      // one with operators (<<if $x + 1>>). We'll wrap
      // complex expressions in parentheses.
      var isSimpleExpression = expressionContext is YarnSpinnerV1ParserExpValueContext;

      // Get the original text of expressionContext. We can't
      // use "expressionContext.GetText()" here, because that
      // just concatenates the text of all captured tokens,
      // and doesn't include text on hidden channels (e.g.
      // whitespace and comments).
      var interval = Interval(expressionContext.Start.StartIndex, expressionContext.Stop.StopIndex);
      String originalText = expressionContext.Start.InputStream.getText(interval);

      String replacementText;

      if (isSimpleExpression) {
        // No need to wrap
        replacementText = originalText + " != 0";
      }
      else {
        // Wrap with parentheses
        replacementText = "(" + originalText + ") != 0";
      }

      var textReplacement0 = TextReplacement;
      textReplacement0.comment = "Converting if statement expression to a boolean";
      textReplacement0.originalText = originalText;
      textReplacement0.startLine = expressionContext.Start.Line;
      textReplacement0.start = expressionContext.Start.StartIndex;
      textReplacement0.replacementText = replacementText;
      _replacements.add(textReplacement0);
    }

  }

  IType visitExpAddSub(ExpAddSubContext context) {

    var expressions = context.expression();

    switch (context.op.Text) {
      case "+": {
        // + supports strings and numbers
        return _checkOperation(context, expressions, context.op.Text, BuiltinTypes.String, BuiltinTypes.number);
      }
      case "-": {
        // - supports only numbers
        return _checkOperation(context, expressions, context.op.Text, BuiltinTypes.number);
      }
      default: {
        throw InvalidOperationException("Internal error: ${nameof(visitExpAddSub)} got unexpected op ${context.op.Text}");
      }
    }
  }

  IType visitExpMultDivMod(ExpMultDivModContext context) {
    var expressions = context.expression();

    // *, /, % all support numbers only
    return _checkOperation(context, expressions, context.op.Text, BuiltinTypes.number);
  }

  IType visitExpPlusMinusEquals(ExpPlusMinusEqualsContext context) {
    List<ParserRuleContext> terms = [context.variable(), context.expression()];

    switch (context.op.Text) {
      case "+=": {
        // + supports strings and numbers
        return _checkOperation(context, terms, context.op.Text, BuiltinTypes.String, BuiltinTypes.number);
      }
      case "-=": {
        // - supports only numbers
        return _checkOperation(context, terms, context.op.Text, BuiltinTypes.number);
      }
      default: {
        throw InvalidOperationException("Internal error: ${nameof(visitExpMultDivMod)} got unexpected op ${context.op.Text}");
      }
    }
  }

  IType visitExpMultDivModEquals(ExpMultDivModEqualsContext context) {
    List<ParserRuleContext> terms = [context.variable(), context.expression()];

    // *, /, % all support numbers only
    return _checkOperation(context, terms, context.op.Text, BuiltinTypes.number);
  }

  IType visitExpComparison(ExpComparisonContext context) {
    List<ParserRuleContext> terms = context.expression();

    // <, <=, >, >= all support numbers only
    _checkOperation(context, terms, context.op.Text, BuiltinTypes.number);

    // Comparisons always return bool
    return BuiltinTypes.bool;
  }

  IType visitExpEquality(ExpEqualityContext context) {
    List<ParserRuleContext> terms = context.expression();

    // == and != support any defined type, as long as terms are the
    // same type
    _checkOperation(context, terms, context.op.Text, BuiltinTypes.number, BuiltinTypes.String, BuiltinTypes.bool);

    // Equality checks always return bool
    return BuiltinTypes.bool;
  }

  IType visitExpNegative(ExpNegativeContext context) {
    List<ParserRuleContext> terms = [context.expression()];

    // - supports only number types
    return _checkOperation(context, terms, "-", BuiltinTypes.number);
  }

  IType visitExpNot(ExpNotContext context) {
    List<ParserRuleContext> terms = [context.expression()];

    // ! supports only bool types
    return _checkOperation(context, terms, "!", BuiltinTypes.bool);
  }

  IType visitSetExpression(SetExpressionContext context) {
    // This is just an expression; visit it
    return visit(context.expression());
  }

  IType visitSetVariableToValue(SetVariableToValueContext context) {
    // Determine the type of the value
    var valueType = visit(context.expression());

    _allSeenVariables.add(context.vAR_ID().getText());

    // Bind the variable to this value
    var typeBinding0 = TypeBinding;
    typeBinding0.variableName = context.vAR_ID().getText();
    typeBinding0.type = valueType;
    _potentialTypeBindings.add(typeBinding0);

    return valueType;
  }
}

class OrderedSet<T> implements ICollection<T> {
  Map<T, LinkedListNode<T>> _Dictionary;
  LinkedList<T> _LinkedList;

  OrderedSet() {
  }

  OrderedSet(IEqualityComparer<T> comparer) {
    Map = Map<T, LinkedListNode<T>>(comparer);
    _linkedList = LinkedList<T>();
  }

  @override
  int get count => Map.count;

  @override
  bool get isReadOnly => Map.isReadOnly;

  @override
  void _system.Collections.Generic.ICollection<T>.Add(T item) {
    add1(item);
  }

  void add(Iterable<T> items) {
    for (var item in items) {
      add1(item);
    }
  }

  @override
  void clear() {
    _linkedList.clear();
    Map.clear();
  }

  @override
  bool remove(T item) {
    var node;
    var nodeRef = RefParam(node);
    bool found = Map.tryGetValue(item, LinkedListNode<T>nodeRef);
    node = nodeRef.value;
    if (!found) {
      return false;
    }


    Map.remove(item);
    _linkedList.remove(node);
    return true;
  }

  @override
  IEnumerator<T> getEnumerator() {
    return _linkedList.getEnumerator();
  }

  @override
  IEnumerator _system.Collections.IEnumerable.GetEnumerator() {
    return getEnumerator();
  }

  @override
  bool contains(T item) {
    return Map.containsKey(item);
  }

  @override
  void copyTo(List<T> array, int arrayIndex) {
    _linkedList.copyTo(array, arrayIndex);
  }

  bool add1(T item) {
    if (Map.containsKey(item)) {
      return false;
    }


    LinkedListNode<T> node = _linkedList.addLast(item);
    Map.add(item, node);
    return true;
  }
}
